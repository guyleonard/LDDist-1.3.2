# This file was automatically generated by SWIG
#
# Module for LDDist
#
#
# Copyright Mikael Thollesson
#
# You may distribute this module under the same terms as perl itself
#
# _history
# February, 2003 v1.1 DNA distances added

# POD documentation - main docs before the code

=head1 NAME

LDDist - Calculation of LogDet pairwise distance for sequence data

=head1 SYNOPSIS

 use LDDist;

 #Create a new taxa-characters matrix object, i.e. alignment
 $theMatrix= LDDist::TCM->new();

 #Populate the matrix with aligned sequences
 for (my $Taxon=1;$Taxon<=$Alignment->no_sequences();$Taxon++) {
 	push @SeqArr, $Alignment->get_seq_by_pos($Taxon)->seq;
 }
 $theMatrix->setTCM(\@SeqArr, $DNA); 

 #Estimate proportion of invariant sites 
 $InvariantFraction = $theMatrix->SidowCRCInvariants(); #or
 $InvariantFraction = $theMatrix->SteelCRCInvariants();
 #And set the invariant parameter
 $theMatrix->SetInvariants($InvariantFraction);
 
 #Use rate classes by
 $theMatrix->SWgrouping($NumberOfRateClasses);
 
 #Calculate LogDet distances
 #For a bootstrapped distance, set $Bootstrap=1, otherwise $Bootstrap=0
 $NumberOfPairs = $theMatrix->LogDetDistances($Bootstrap);
 #Retrieve the pairwise distances into an array (lower, no diagonal)
 @Distances = $theMatrix->getDistance(0);
 for (my $thePair=1;$thePair<$NumberOfPairs;$thePair++) {
 	push @Distances, $theMatrix->getDistance($thePair);
 }
   
=head1 DESCRIPTION

LDDist is a module that allows the user to calculate LogDet pair-wise genetic distances 
from amino acid as well as DNA/RNA sequence data

=head1 FEEDBACK

LDDist@artedi.ebc.uu.se

=head1 AUTHOR

Mikael Thollesson, Uppsala University

=cut

# 'Let the code begin...

package LDDist;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package LDDistc;
bootstrap LDDist;
package LDDist;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package LDDist;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package LDDist;

*GetVersion = *LDDistc::GetVersion;

############# Class : LDDist::TCM ##############

package LDDist::TCM;
@ISA = qw( LDDist );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my @args = @_;
    my $self = LDDistc::new_TCM(@args);
    return undef if (!defined($self));
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "LDDist::TCM", $self;
    return bless \%retval, $pkg;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LDDistc::delete_TCM($self);
        delete $OWNER{$self};
    }
}

*SidowCRCInvariants = *LDDistc::TCM_SidowCRCInvariants;
*SWgrouping = *LDDistc::TCM_SWgrouping;
*SetInvariants = *LDDistc::TCM_SetInvariants;
*SteelCRCInvariants = *LDDistc::TCM_SteelCRCInvariants;
*LogDetDistances = *LDDistc::TCM_LogDetDistances;
*setTCM = *LDDistc::TCM_setTCM;
*getDistance = *LDDistc::TCM_getDistance;
*GetRateClass = *LDDistc::TCM_GetRateClass;
*SetRateClass = *LDDistc::TCM_SetRateClass;
*NewRateClasses = *LDDistc::TCM_NewRateClasses;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };


# ------- VARIABLE STUBS --------

package LDDist;

1;
